<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>
    
      Introducing ActiveRecord Futures &ndash;
    
    Leonardo Garcia Crespo
  </title>

  <meta name="author" content="Leonardo Garcia Crespo" />
  <meta name="description" content="Sharing my thoughts to the world" />

  <link rel="alternate" type="application/rss+xml" href="/atom.xml" />

  <link type="text/css" rel="stylesheet" href="/assets/app-069c33e98bdadd80eeea11c2930774a9cd75fe707f8b0406b35c3c0961a2df9e.css">
  <link type="text/css" rel="stylesheet" href="/assets/syntax-891384f4103a9322d940126665632dfdcde8aa583582093f916f548c78e66ba8.css">

  <link href='//fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <script type="text/javascript" src="/assets/app-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.js"></script>
  
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37579559-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  
</head>

<body>
  <header>
    <nav>
    <ul>
      <li>
        <a href="/">
          <img src="https://gravatar.com/avatar/2d4686084d18b4991674f0cd4fbc6c58?s=150" height="25" width="25" class="avatar" />
        </a>
      </li>
      <li><a href="/">Posts</a></li>
      <li><a href="/about.html">About</a></li>
      <li><a href="/atom.xml">RSS</a></li>
      <li><a href="https://github.com/leoasis" target="_blank">Github</a></li>
      <li><a href="https://twitter.com/leogcrespo" target="_blank">Twitter</a></li>
    </ul>
  </nav>
</header>

  <main>
    <section class="content">
  <h1>
    <a href="/posts/2013/05/16/activerecord-futures">Introducing ActiveRecord Futures</a>
  </h1>

  <section class="byline">
    May 16, 2013
  </section>

  <p>I’m back! Long time no see!</p>

<p>I’ve been in a mix of lazyness, busy, short on ideas to post, and waiting to finish some projects I’ve been working on.</p>

<p>This is one of them. I’ve released a gem and reached a feature-enough state, enough at least to write a post about it. The idea grew from past experience with .NET and NHibernate, and trying to find something similar in the Ruby world, especially in the Rails world.</p>

<p>If you don’t want to read the story and motivation of it, and just want to rush to the code, here it is:</p>

<p><a href="https://github.com/leoasis/activerecord-futures">https://github.com/leoasis/activerecord-futures</a></p>

<h2 id="the-problem">The Problem</h2>

<p>What I wanted to tackle with this gem was the fact that most performance problems in any web application are due to IO. Especially database IO. As you may already know, reading from disk or from the network are costly operations. And if you have your database in a separate server, which you should in production, you have both!</p>

<p>Also, if database access is done synchronously, it will block, wasting precious time that you could be using to do other stuff. Well, you know, you could access asynchronously, and have all IO access non blocking. But I am talking about Rails here, so let’s stick with blocking access.</p>

<p>So the first thing you should try to do is have the least number of queries per request you can have. Trying to eagerly include associations when you know that you will need them right away, avoid select n + 1, caching, and all that stuff. Those tips are vital to increasing the performance of our app, but still, there’s more you can do.</p>

<p>It’s a very common thing to need several queries to fulfill a request. And they are not always solvable eagerly including associations, since those queries do not always involve associations. For example, say you want to have a list of articles that is paginated. You would do something like this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># inside an action in a controller...</span>
<span class="n">page_size</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">page_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:page</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">page_size</span>
<span class="vi">@articles</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="n">page_size</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="n">page_start</span><span class="p">)</span>
<span class="vi">@articles_count</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">count</span>
</code></pre>
</div>

<p>Of course, you are using a gem to paginate, and not doing this manually. I did this to show you more explicitly that pagination involves always two queries to the database. Well, you might say that there’s no way to reduce those 2 queries any further, and you’d be right. You <em>DO</em> need those 2 queries. But do you need to go <em>twice</em> to the database and ask for a single query each time? No! we could issue both queries in a single round trip, using multiple statements.</p>

<p>Before going further with this, let’s see another example. Suppose you are now diplaying the index page of a marketplace, where you see the newest articles, the top shoppers, the top purchased categories and interesting articles based on your previous purchases. You may have something like this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="vi">@newest_articles</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"published_at desc"</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="vi">@top_shoppers</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"purchase_count desc"</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="vi">@top_categories</span> <span class="o">=</span> <span class="no">Category</span><span class="p">.</span><span class="nf">most_purchased</span>
<span class="vi">@interesting_articles</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">interesting_for</span><span class="p">(</span><span class="n">current_user</span><span class="p">)</span>
</code></pre>
</div>

<p>Here you see again that we cannot reduce the query amount any further, since that is exactly the info that we need to show. Still, we’re making 4 database round trips, without counting the potential extra one for <code class="highlighter-rouge">current_user</code>. We can do better than that!</p>

<h2 id="the-solution">The Solution</h2>

<p>Meet <a href="https://github.com/leoasis/activerecord-futures">ActiveRecord::Futures</a>.</p>

<p>This gem extends ActiveRecord by allowing it to do just that: batch queries in a single round trip to the database. It makes use of multiple statements, which is simply sending a set of queries in a single text command, and receiving a response that is the set of results of those queries. Internally the gem multiplexes the results to the corresponding places.</p>

<p>Using the future pattern, you build up your relation with the conditions that you need, and before retrieving the result, you tell it that you want a “future value”, that is, a value that you will use later on. Let’s use the pagination example for this. This is how you would rewrite it:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># inside an action in a controller...</span>
<span class="n">page_size</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">page_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:page</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">page_size</span>
<span class="vi">@articles</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="n">page_size</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="n">page_start</span><span class="p">).</span><span class="nf">future</span>
<span class="vi">@articles_count</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">future_count</span><span class="p">.</span><span class="nf">value</span>
</code></pre>
</div>

<p>Notice the <code class="highlighter-rouge">future</code> and <code class="highlighter-rouge">future_count.value</code> changes? Let’s see what this does. The <code class="highlighter-rouge">future</code> call tells the relation that you want the result from the query it builds, but not yet. It enqueues the query in a list, waiting to be sent when it really needs to. <code class="highlighter-rouge">future_count</code> does something similar. But instead of equeuing the query of the relation, it enqueues the <code class="highlighter-rouge">count</code> of it.</p>

<p>Now here comes the important part. When we call <code class="highlighter-rouge">value</code> on the object returned from <code class="highlighter-rouge">future_count</code>, we are now saying that we want the result <em>now</em>. We are triggering the future. And when that happens, all the queued queries will be sent at once to the database, then received at once after the <em>single round trip</em>, and sent back to the respective futures. So <code class="highlighter-rouge">value</code> will return the result of the count query, and enumerating  the <code class="highlighter-rouge">@articles</code> (or calling <code class="highlighter-rouge">to_a</code>) will return the array of articles. One thing to note here is that when we do the latter action, <em>no query will be sent</em>, since the result is already there, it came from the previous action.</p>

<p>This is what we gain. Same amount of queries, less round trips to the database. Nice, isn’t it?</p>

<p>That’s the idea behind <a href="https://github.com/leoasis/activerecord-futures">ActiveRecord::Futures</a>. If you want to see more, just go to the <a href="https://github.com/leoasis/activerecord-futures">Github repo</a> and check the Readme.</p>

<p>See ya!</p>


  <section class="meta">
  <h3>Discussion, links, and tweets</h3>
  <section class="copy">
    <a href="//twitter.com/leogcrespo" target="_blank">
      <img src="https://gravatar.com/avatar/2d4686084d18b4991674f0cd4fbc6c58?s=142" height="50" width="50" />
    </a>

    <p>
      Feel free to ask any questions or give me feedback about any post, new or old, doesn't matter (<a href="//twitter.com/leogcrespo" target="_blank">@leogcrespo</a>).
    </p>

    <a href="//twitter.com/share" class="twitter-share-button" data-count="none" data-via="leogcrespo">Tweet</a>
    <a href="//twitter.com/leogcrespo" class="twitter-follow-button" data-show-count="false">Follow @leogcrespo</a>
    <script src="//platform.twitter.com/widgets.js" type="text/javascript"></script>
  </section>
</section>

  
  <div id="disqus_thread"></div>
  <script>

    var disqus_config = function () {
      this.page.url = 'https://leoasis.github.io/posts/2013/05/16/activerecord-futures';
      this.page.identifier = '/posts/2013/05/16/activerecord-futures';
    };

    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://leogcrespo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</section>

  </main>
  <footer>
  <p>
  Made with ❤️ by <a href="https://twitter.com/leogcrespo" target="_blank">Lenny</a>
  </p>
</footer>

</body>

</html>
