<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>
    
      Reparenting a Component &ndash;
    
    Leonardo Garcia Crespo
  </title>

  <meta name="author" content="Leonardo Garcia Crespo" />
  <meta name="description" content="Sharing my thoughts to the world" />

  <link rel="alternate" type="application/rss+xml" href="/atom.xml" />

  <link type="text/css" rel="stylesheet" href="/assets/app-069c33e98bdadd80eeea11c2930774a9cd75fe707f8b0406b35c3c0961a2df9e.css">
  <link type="text/css" rel="stylesheet" href="/assets/syntax-891384f4103a9322d940126665632dfdcde8aa583582093f916f548c78e66ba8.css">

  <link href='//fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <script type="text/javascript" src="/assets/app-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.js"></script>
  
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37579559-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  
</head>

<body>
  <header>
    <nav>
    <ul>
      <li>
        <a href="/">
          <img src="https://gravatar.com/avatar/2d4686084d18b4991674f0cd4fbc6c58?s=150" height="25" width="25" class="avatar" />
        </a>
      </li>
      <li><a href="/">Posts</a></li>
      <li><a href="/about.html">About</a></li>
      <li><a href="/atom.xml">RSS</a></li>
      <li><a href="https://github.com/leoasis" target="_blank">Github</a></li>
      <li><a href="https://twitter.com/leogcrespo" target="_blank">Twitter</a></li>
    </ul>
  </nav>
</header>

  <main>
    <section class="content">
  <h1>
    <a href="/posts/2017/06/26/reparenting-a-component">Reparenting a Component</a>
  </h1>

  <section class="byline">
    June 26, 2017
  </section>

  <p>When working with React, we almost never have to think about the underlying <a href="https://facebook.github.io/react/docs/reconciliation.html">reconciliation algorithm</a> that calculates the update to the DOM. It just works: we write our components with the UI logic inside the render function, handle events and perform state changes, and bam!, we’re done. If we’re working with arrays, the reconciliation algorithm may ask us to provide the <code class="highlighter-rouge">key</code> attribute, but that’s okay when you <a href="https://facebook.github.io/react/docs/lists-and-keys.html">understand how keys work</a>.</p>

<p>In most cases, especially if the data is flowing exclusively via props, it doesn’t matter if we’re updating a component or mounting a new one. Since the data to render is all provided to the component, the final result will be the same if the component got updated, or if React had to mount it because it wasn’t there.</p>

<p>But there are cases where the reconciliation becomes a leaky abstraction. If we’re relying on the component’s local state for something, or if we’re dealing with state that lives in the DOM (like selection state inside form inputs), then it <em>does</em> matter if we’re updating a component or creating a new one, because that would mean we will <em>retain</em> that internal state, or wipe it and start with a fresh one.</p>

<p>So why a leaky abstraction? That’s because you need to know <em>when</em> React will decide to mount or update a component. To know a bit more about it, I suggest you to <a href="TODO">read the documentation about the heuristics inside the reconciliation algorithm</a>. Two important ones relevant to this post are:</p>

<ol>
  <li>React will unmount the old tree of components and remount a new one if the new root of the tree is of a different type than the previous one.</li>
  <li>Keys to assign identity to a component while diffing is only supported locally (i.e. inside a component’s render function) for siblings, but it’s not able to identify and “reparent” between completely different nodes in the component tree.</li>
</ol>

<p>In my particular use case, I had a panel that collapsed or expanded showing some items depending on the page where it was rendered. But that panel was nested in a component that would become unmounted whenever the page changed, because the component type was already different a couple of levels above in the tree, making the reconciliation algorithm wipe the subtree and create a new one with the component with the new type as a root.</p>

<p>That collapse and expansion was done with an animation whenever we detected the component’s children <em>changed</em>, so I needed to have a way to detect that change. But since the component was being unmounted and remounted, the animation never triggered, as the state never technically changed.</p>

<p>Ideally, that could have been solved by designing the component tree so that the reconciliation worked <em>with</em> us (instead of against us). For example, if this panel lived in a sidebar that is shown in both pages, a valid solution would have been to move that sidebar component to a layout component, and only re-render the main content whenever the url changes. That way, the sidebar would be updated and not remounted because the parents’ types would be the same.</p>

<p>That may have been an option in my particular case, even though we didn’t go with it for other reasons. But anyway, I believe there are plenty of valid use cases where doing that is not possible, at least not easily. In those cases, you need to resort to other solutions.</p>

<p>So I tried to make reparenting work. This is what I came up with to solve it, I will explain what’s going on below, but here is the code:</p>

<script src="https://gist.github.com/leoasis/e1d093141e5f22e4e1e346e6726dfa5b.js?file=01.js"></script>

<p>And to use it, you need to wrap the component that can be reparented in this <code class="highlighter-rouge">Reparentable</code> component, in all the places where it should be rendered, like this:</p>

<script src="https://gist.github.com/leoasis/e1d093141e5f22e4e1e346e6726dfa5b.js?file=02.js"></script>

<p>Thanks to React’s nice API, the way to use this component is still pretty straightforward. There’s nothing more than rendering components and passing props.</p>

<p>So let’s talk about what’s going on in the implementation of that component. The trick of all this is to <em>keep the references of the DOM nodes</em> that React uses to render a component and then call <code class="highlighter-rouge">ReactDOM.render</code> on them, so that React updates whatever instance was previously rendered in those nodes.</p>

<p>The <code class="highlighter-rouge">Reparentable</code> component renders a single div, to which we attach a ref to hold on to the DOM element instance. Then in the <code class="highlighter-rouge">componentDidMount</code> and <code class="highlighter-rouge">componentDidUpdate</code> lifecycle hooks, we get (or create if it doesn’t exist yet) a DOM node based on the <code class="highlighter-rouge">uid</code> prop we received, append it to our div if we didn’t already, and tell React to render the children into that DOM node. If the <code class="highlighter-rouge">uid</code> is the same, the DOM node we get will be the same, so rendering into the same DOM node will make React perform the reconciliation there. Since we are rendering the same type of element, the component will be <em>updated</em> by React instead of mounted.</p>

<p>When the <code class="highlighter-rouge">Reparentable</code> component unmounts, it will remove the DOM node we were using to render the children, but we’ll still keep the reference around in a global object. Notice that we don’t unmount the React instance in that node yet. We wait a bit for that, in case another <code class="highlighter-rouge">Reparentable</code> component attempts to use it (by rendering with the same <code class="highlighter-rouge">ui</code> prop). If that happens, we will keep the DOM node reference around since it was claimed. If that doesn’t happen, then we effectively unmount the React instance in that node and we remove the reference so that it can be garbage collected by the JS runtime.</p>

<p>Because we don’t unmount the instance if it gets used by another <code class="highlighter-rouge">Reparentable</code> instance, we effectively reparented the DOM node and the instance, and the next time it receives a render, it will update the instance, instead of mounting it.</p>

<p>One more thing to notice is that the example is using <code class="highlighter-rouge">ReactDOM.unstable_renderSubtreeIntoContainer</code> instead of <code class="highlighter-rouge">ReactDOM.render</code>. This is because the former allows to propagate the <code class="highlighter-rouge">context</code> into that subtree, which is not possible if we called <code class="highlighter-rouge">ReactDOM.render</code>, since it assumes we want to render a completely isolated tree. The fact that the name contains <code class="highlighter-rouge">unstable</code> in it should be enough warning not to use it, but there is no other way to achieve this context propagation as far as I know. Maybe this method will become stable in a future version of React, or a better solution will be available.</p>

<p>Here is an example of how you see it in action:</p>

<p><img src="/assets/2017-06-26-reparenting-a-component-4f9f379342207f7eca23d8886f149543ef920927d6c89ca39f767d93c1487043.gif" width="501" height="111" alt="2017-06-26-reparenting-a-component.gif" /></p>

<p>Notice how the state is preserved (the click count and the text inside the input) when switching pages, which is destroying the entire tree for the old page and creating the tree for the new page.</p>

<h2 id="problems">Problems</h2>

<p>As you may imagine, no solution is perfect, and actually this solution has a couple of important problems. One problem is that it relies on the user assigning unique global <code class="highlighter-rouge">uid</code>s. If you ever render two <code class="highlighter-rouge">Reparentable</code> components at the same time with the same <code class="highlighter-rouge">uid</code>, the last one to mount will steal the DOM node from the other one, which is surely not what you want.</p>

<p>Another problem is the hacky way we have to know if the DOM node is going to be reparented: we keep the node alive for some time (in our case, we wait until the next event loop tick), and after that we unmount and remove the reference. But the truth is that we can never be sure if the node is going to be used again at any point in the future. So waiting “for a bit” is not reliable.</p>

<p>If you are interested in this problem, and similar related problems, I suggest you to go to this thread and read it:</p>

<p><a href="https://gist.github.com/chenglou/34b155691a6f58091953">https://gist.github.com/chenglou/34b155691a6f58091953</a></p>

<p>There are some great ideas on how to solve this problem properly in that thread, and I hope that at some point those ideas become useful to bake a reparenting solution right inside React in the future.</p>

<p>This solution worked well for us, it’s far from perfect, but at least shows the idea behind reusing nodes with React instances mounted on them to support reparenting.</p>

<p>Hope you find this useful! If you had a similar problem and you solved it differently, be sure to leave a comment or tweet to me and share your approach.</p>

  <section class="meta">
  <h3>Discussion, links, and tweets</h3>
  <section class="copy">
    <a href="//twitter.com/leogcrespo" target="_blank">
      <img src="https://gravatar.com/avatar/2d4686084d18b4991674f0cd4fbc6c58?s=142" height="50" width="50" />
    </a>

    <p>
      Feel free to ask any questions or give me feedback about any post, new or old, doesn't matter (<a href="//twitter.com/leogcrespo" target="_blank">@leogcrespo</a>).
    </p>

    <a href="//twitter.com/share" class="twitter-share-button" data-count="none" data-via="leogcrespo">Tweet</a>
    <a href="//twitter.com/leogcrespo" class="twitter-follow-button" data-show-count="false">Follow @leogcrespo</a>
    <script src="//platform.twitter.com/widgets.js" type="text/javascript"></script>
  </section>
</section>

  
  <div id="disqus_thread"></div>
  <script>

    var disqus_config = function () {
      this.page.url = 'https://leoasis.github.io/posts/2017/06/26/reparenting-a-component';
      this.page.identifier = '/posts/2017/06/26/reparenting-a-component';
    };

    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://leogcrespo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</section>

  </main>
  <footer>
  <p>
  Made with ❤️ by <a href="https://twitter.com/leogcrespo" target="_blank">Lenny</a>
  </p>
</footer>

</body>

</html>
