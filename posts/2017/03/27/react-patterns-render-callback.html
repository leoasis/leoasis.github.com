<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>
    
      React Patterns - Render Callback &ndash;
    
    Leonardo Garcia Crespo
  </title>

  <meta name="author" content="Leonardo Garcia Crespo" />
  <meta name="description" content="Sharing my thoughts to the world" />

  <link rel="alternate" type="application/rss+xml" href="/atom.xml" />

  <link type="text/css" rel="stylesheet" href="/assets/app-069c33e98bdadd80eeea11c2930774a9cd75fe707f8b0406b35c3c0961a2df9e.css">
  <link type="text/css" rel="stylesheet" href="/assets/syntax-891384f4103a9322d940126665632dfdcde8aa583582093f916f548c78e66ba8.css">

  <link href='//fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <script type="text/javascript" src="/assets/app-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.js"></script>
  
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37579559-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  
</head>

<body>
  <header>
    <nav>
    <ul>
      <li>
        <a href="/">
          <img src="https://gravatar.com/avatar/2d4686084d18b4991674f0cd4fbc6c58?s=150" height="25" width="25" class="avatar" />
        </a>
      </li>
      <li><a href="/">Posts</a></li>
      <li><a href="/about.html">About</a></li>
      <li><a href="/atom.xml">RSS</a></li>
      <li><a href="https://github.com/leoasis" target="_blank">Github</a></li>
      <li><a href="https://twitter.com/leogcrespo" target="_blank">Twitter</a></li>
    </ul>
  </nav>
</header>

  <main>
    <section class="content">
  <h1>
    <a href="/posts/2017/03/27/react-patterns-render-callback">React Patterns - Render Callback</a>
  </h1>

  <section class="byline">
    March 27, 2017
  </section>

  <p>I wanted to start documenting some React patterns that are common when developing. Most importantly because doing this will make me do some research in order to understand more accurately when those patterns are a good fit and when they aren’t, and what are the tradeoffs involved in using or not using them. Hope you find these posts as useful as they are for me!</p>

<p>So today, I want to start with this pattern called “Render callbacks”. I think the name was coined by <a href="https://twitter.com/ryanflorence">Ryan Florence</a> on Twitter, not happy with the alternative name “function as child”, which was not entirely precise, as this pattern isn’t only constrained to the <code class="highlighter-rouge">children</code> prop.</p>

<h2 id="when-to-use-it">When to use it</h2>

<p>You want to extract some functionality you have in a component, the parent, into another component, that will be rendered as a child of that parent. The functionality can’t entirely live in the child component, and thus configuring it with simple value props is not enough. You want the child to do something, but then some part of the logic requires the parent to provide it with something further to do.</p>

<p>Basically what you want is a way for the parent to provide some logic to the child, and the child have the control on how to execute that logic.</p>

<h2 id="what-it-is">What it is</h2>

<p>You provide the child component with a function prop that will be called at some point internally in the child. This prop is called the “render callback”. That function is able to receive parameters that will be assigned by the child the moment it is called, with the information the child has when doing its stuff. The child is the one to decide if it wants to call that function or not, again depending on its internal logic.</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=01.js"></script>

<p>In the child, simply call the prop as a function wherever (and if) it makes sense, passing the relevant parameters to it:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=02.js"></script>

<p>Let’s see an example to make that a little clearer…</p>

<h2 id="an-example-component-to-do-data-fetching">An example: Component to do data fetching</h2>

<p>Let’s say you have a component that needs to fetch some data in order to render it somehow. Maybe you’d do something like this:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=03.js"></script>

<p>We’re using the component’s lifecycle and state to accomplish what we want. We store in the state wether we have loaded data or not, wether we had an error from the request or not, and the data itself, when the request succeeds. Then in the <code class="highlighter-rouge">componentDidMount</code> lifecycle hook, we go and perform the fetch, using the necessary props, and update the state when we have a successful request, and when we have a failure.</p>

<blockquote>
  <p>Note: If we wanted a more complete example, we’d also have to add code in <code class="highlighter-rouge">componentWillReceiveProps</code> and <code class="highlighter-rouge">componentDidUpdate</code> to handle the case where the props relevant to the fetch request change (<code class="highlighter-rouge">userId</code> in this case), and perform a new request (and maybe cancel/ignore the previous one if it’s still inflight). For simplicity, this is not included in the example.</p>
</blockquote>

<p>Finally, we have our render function, that uses all that state and either renders a loading screen, an error message, or the actual results in a nice way, accordingly.</p>

<p>Let’s think about what this component is doing. We’re having multiple responsibilities: handling the logic around fetching data, coping with loading and error states, and also rendering all those states. What we want is to extract the logic regarding fetching data, dealing with the different states, and rendering the loading and error states. We only care about rendering the successful data in our component.</p>

<p>Let’s start writing something about how we’d want to use this component in our original one. We know for sure we’ll pass the necessary parameters to fetch the data as props, in this case, the <code class="highlighter-rouge">userId</code>:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=04.js"></script>

<p>Now, in order to <em>provide</em> the child component with the necessary info to render the data when the request is successful, we’ll provide a render callback prop. That render callback should receive the data as its first parameter:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=05.js"></script>

<p>With that usage in mind, this is the implementation of <code class="highlighter-rouge">FetchStuff</code>:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=06.js"></script>

<p>Notice how we call <code class="highlighter-rouge">this.props.renderData(...)</code> as a function and pass the relevant parameters into it. That’s the pattern in action. We extracted all the functionality that we didn’t want to live in <code class="highlighter-rouge">StuffList</code> and moved it into a reusable component that accepts a function to determine how to render the data it fetched.</p>

<h2 id="another-example-a-tooltip">Another example: A tooltip</h2>

<p>Say you want to use a tooltip component. This is one way to do it:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=07.js"></script>

<p>We wrap some element around a <code class="highlighter-rouge">TooltipTrigger</code> component, which wraps the children in an element that when hovered, will show the tooltip. We specify the content of the tooltip as a prop that accepts a react element. A simple implementation of the <code class="highlighter-rouge">TooltipTrigger</code> could be something like this:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=08.js"></script>

<p>Notice we only render the <code class="highlighter-rouge">Tooltip</code> component whenever we’re hovering the <code class="highlighter-rouge">div</code>, and we don’t render it otherwise. Ok that was fairly easy, right?</p>

<p>Let’s think about some potential problems this solution has: What if the content of the tooltip is complex enough that you don’t want to create the react elements until you really need to show them? Or maybe you don’t have the necessary information for that content yet. It’d be really nice to be able to provide the contents in a lazy way, such that the elements are only created when the <code class="highlighter-rouge">TooltipTrigger</code> considers it’s needed. Sounds like a nice use case for a <em>render callback</em>.</p>

<p>If we didn’t wrap the content in a render callback, the elements would be created right away even when the tooltip decides not to render them yet. Fairly enough, these are just lightweight objects that only <em>describe</em> what the UI will look like, but it’s still work we don’t need to do. Also, if the content depends on getting the info from data we don’t yet have, trying to access it right away would cause a runtime error, especially if we need to access nested properties.</p>

<p>So now, let’s try passing a render callback instead of passing a react element as the content. Let’s see how that looks in the code:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=09.js"></script>

<p>And this is how we’d modify the <code class="highlighter-rouge">TooltipTrigger</code> implementation:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=10.js"></script>

<p>Here we are using the render callback to render some content whenever the tooltip is hovered. The only change needed in the <code class="highlighter-rouge">TooltipTrigger</code> implementation is the use of <code class="highlighter-rouge">this.props.tooltipContent</code>, which now is a function and we have to call it to get the elements.</p>

<p>In this case, compared to the previous example, we used the render callback pattern in the tooltip to delegate the responsibility of wether to render something or not, to another component.</p>

<h2 id="more-examples-in-the-wild">More examples in the wild</h2>

<p>There are a lot of examples out there that make use of this pattern. Let’s see some of those with a short explanation of each.</p>

<h3 id="react-router">React router</h3>

<p><a href="https://github.com/ReactTraining/react-router">https://github.com/ReactTraining/react-router</a></p>

<p>Uses the pattern to do both things actually. The <code class="highlighter-rouge">Route</code> component fetches the location data and query string params from the history, and passes that info to the function provided as render callback. Also, it decides wether to call the function or not depending on wether the route matches the path or not.</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=11.js"></script>

<h3 id="react-measure">React Measure</h3>

<p><a href="https://github.com/souporserious/react-measure">https://github.com/souporserious/react-measure</a></p>

<p>Measures the dimensions of an element (width, height, top, bottom, etc) and provides it as the parameter of the render callback, which allows the parent component to do any kind of crazy logic with the dimensions.</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=12.js"></script>

<p>What’s interesting here is that the render callback in this case is passed as <code class="highlighter-rouge">children</code>. This may look like something special is going on here, but remember that in React, the <code class="highlighter-rouge">children</code> prop is just another prop, only that it has some syntactic sugar that allows it to be passed as the content of the JSX tag.</p>

<h3 id="react-media">React Media</h3>

<p><a href="https://github.com/reacttraining/react-media">https://github.com/reacttraining/react-media</a></p>

<p>Same idea as before, but in this case the parameter that is injected into the render callback is wether the media query specified as prop matches or not:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=13.js"></script>

<h3 id="react-motion">React-Motion</h3>

<p><a href="https://github.com/chenglou/react-motion">https://github.com/chenglou/react-motion</a></p>

<p>A library that let’s you create animations. You specify the animation configuration as props to the <code class="highlighter-rouge">Motion</code> component, and you also pass a render callback as the children. The callback gets called repeatedly with the intermediate values of the calculated animation, rendering all the intermediate states of the UI.</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=14.js"></script>

<h3 id="react-natives-listview">React Native’s ListView</h3>

<p><a href="https://facebook.github.io/react-native/docs/listview.html">https://facebook.github.io/react-native/docs/listview.html</a></p>

<p>One way to create lists in React Native is with a <code class="highlighter-rouge">ListView</code>, provided in the core React Native library. Instead of directly rendering the list of items as children of the component, it defines the <code class="highlighter-rouge">renderRow</code> prop which is a render callback that specifies how to render a row given the data for that item, which is specified in another prop called the <code class="highlighter-rouge">dataSource</code>. In this case, the render callback pattern is used to specify placeholders for custom content that the <code class="highlighter-rouge">ListView</code> can use internally while rendering the list. This also allows for internal performance optimizations, since the component can decide when to render each item in a granular way.</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=15.js"></script>

<h2 id="advantages">Advantages</h2>

<p>We’ve already seen some of the advantages of this pattern. The most obvious one is that it helps to decouple your rendering logic from the way to get the necessary data to actually render, or the logic to conditionally render that.</p>

<p>Another benefit, is that because we’re using components, the render method is still declarative, and it’s easy to see at a glance what’s going on.</p>

<p>Also, contrary to using <a href="https://facebook.github.io/react/docs/higher-order-components.html">Higher order components (HoC)</a>, you don’t pollute your props namespace with the props that can be potentially injected by HoCs. In render callbacks, the injected stuff comes as parameters.</p>

<h2 id="disadvantages">Disadvantages</h2>

<p>No pattern comes without its drawbacks. As we all know, everything is a matter of tradeoffs…</p>

<p>One problem the pattern has, is that since we’re creating a function inline in every render, that may conflict with some optimizations that could be done in the <code class="highlighter-rouge">shouldComponentUpdate</code> hook in the component that receives the render callback. Since the function is a new instance every time, shallow comparison of the props is no longer a valid solution. You could probably hoist the render callback or pre-bind it if using <code class="highlighter-rouge">this</code>, but that’d reduce the advantage of being able to quickly scan the <code class="highlighter-rouge">render</code> method and see what’s going on. This is probably subjective though.</p>

<p>This pattern also is not suitable when the data required to render something is also needed in some life cycle hook. This includes being able to do side effects, because those cannot be done in the render method, so you need to do them in some lifecycle hook that allows them.</p>

<p>This is because the render callback is passed as a prop to another component in the render method, so you don’t have access to those parameters outside the function, and particularly not in the lifecycle hooks of the parent. If you need that though, you can pass the parameters as props into another component that contains the rendering logic you previously had inlined in the render callback. At that point, you’re dealing with a regular component that gets its data injected via props. Another option would be to use a <a href="https://facebook.github.io/react/docs/higher-order-components.html">Higher order component (HoC)</a>.</p>

<p>One caveat with this approach that you could run into pretty easily, is potentially using stale props or state inside the render callback. This happens if you use <em>destructuring</em> of props or state and use those values inside the render callback as a closure. Here’s an example of this:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=16.js"></script>

<p>This may be a contrived example, but tends to happen often in practice. In this case, if you attempted to render the <code class="highlighter-rouge">Greeter</code> component more than once with a different <code class="highlighter-rouge">name</code> prop, you’d still be seeing the message that updates every second using the first prop ever passed. That’s because the first <code class="highlighter-rouge">renderEverySecond</code> render callback is being stored internally inside the <code class="highlighter-rouge">Clock</code> component and that’s the function being executed every second. Even if future renders of <code class="highlighter-rouge">Greeter</code> passed a new <code class="highlighter-rouge">renderEverySecond</code> function with the <code class="highlighter-rouge">name</code> prop being properly closed over, since the first one is being used, we only ever see the first name.</p>

<p>One fix would be to make <code class="highlighter-rouge">Clock</code> properly use its most current <code class="highlighter-rouge">renderEverySecond</code> prop, which is achieved by not destructuring it in <code class="highlighter-rouge">componentDidMount</code>:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=17.js"></script>

<p>Another fix would be to make the <code class="highlighter-rouge">renderEverySecond</code> render callback use the most current value for <code class="highlighter-rouge">name</code>, again by avoiding destructuring and using directly the most current set of <code class="highlighter-rouge">props</code>:</p>

<script src="https://gist.github.com/leoasis/367b556688e1aa0fb21f9b4d966079d6.js?file=18.js"></script>

<p>One final drawback that render callbacks have is that since they compose dynamically at <em>render time</em>, they don’t allow optimizations that could be done if the parameters to be injected were static. You could treat some props received by the child component as <em>static</em> and not update the render callback parameters when they change to have those optimizations, but that kind of breaks the component contract, since the user of that component would expect the prop change to be taken into account. Using things like <a href="https://facebook.github.io/react/docs/higher-order-components.html">Higher order components</a> may be a better solution for static configuration of a component, which move that said configuration to <em>declaration time</em>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We saw what the <em>render callback</em> pattern is, how to use it and when it helps us when developing with React. We also saw some examples in the wild where it’s being used, and we also analized (some of) its advantages and disadvantages, mostly compared to its “nemesis” the <a href="https://facebook.github.io/react/docs/higher-order-components.html">Higher order component</a>, which is also a pattern to solve similar problems.</p>

<p>It seems that for most of the use cases, it ends up being a matter of taste wether to choose the render callback pattern, or the <a href="https://facebook.github.io/react/docs/higher-order-components.html">Higher order component</a> pattern. Both let you achieve the same thing, but choose different tradeoffs. You can even choose one patter to solve some things in your app, and the other one to solve other things. They can live happily together.</p>

<p>Hope this post taught you something, made your ideas clearer, or at least didn’t tell you anything incorrect (if so, add a comment and will fix!). Also feel free to comment to add more advantages or disadvantages that I may have missed.</p>

<p>Have a great day!</p>

  <section class="meta">
  <h3>Discussion, links, and tweets</h3>
  <section class="copy">
    <a href="//twitter.com/leogcrespo" target="_blank">
      <img src="https://gravatar.com/avatar/2d4686084d18b4991674f0cd4fbc6c58?s=142" height="50" width="50" />
    </a>

    <p>
      Feel free to ask any questions or give me feedback about any post, new or old, doesn't matter (<a href="//twitter.com/leogcrespo" target="_blank">@leogcrespo</a>).
    </p>

    <a href="//twitter.com/share" class="twitter-share-button" data-count="none" data-via="leogcrespo">Tweet</a>
    <a href="//twitter.com/leogcrespo" class="twitter-follow-button" data-show-count="false">Follow @leogcrespo</a>
    <script src="//platform.twitter.com/widgets.js" type="text/javascript"></script>
  </section>
</section>

  
  <div id="disqus_thread"></div>
  <script>

    var disqus_config = function () {
      this.page.url = 'https://leoasis.github.io/posts/2017/03/27/react-patterns-render-callback';
      this.page.identifier = '/posts/2017/03/27/react-patterns-render-callback';
    };

    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://leogcrespo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



</section>

  </main>
  <footer>
  <p>
  Made with ❤️ by <a href="https://twitter.com/leogcrespo" target="_blank">Lenny</a>
  </p>
</footer>

</body>

</html>
